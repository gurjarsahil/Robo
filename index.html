<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Simulator with Improved Robot Design</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    /* Info panel in the top-left */
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
    }
    /* Control panel in the top-right */
    #controlPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
    }
    #controlPanel label, #controlPanel span {
      font-size: 14px;
    }
    
    /* Navigation Controls */
    #navigationPanel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      z-index: 10;
      text-align: center;
    }
    
    .nav-button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      margin: 3px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    .nav-button:hover {
      background: #45a049;
    }
    
    .nav-button:active {
      background: #3d8b40;
      transform: scale(0.95);
    }
    
    .nav-button.danger {
      background: #f44336;
    }
    
    .nav-button.danger:hover {
      background: #da190b;
    }
    
    .nav-button.goal {
      background: #2196F3;
    }
    
    .nav-button.goal:hover {
      background: #0b7dda;
    }
    
    .direction-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin: 10px 0;
    }
    
    .direction-grid .nav-button {
      padding: 8px;
      font-size: 12px;
    }
    
    #positionInfo {
      position: absolute;
      bottom: 10px;
      left: 150px;
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
      font-family: monospace;
    }
    
    .control-group {
      margin: 10px 0;
      padding: 8px;
      border: 1px solid #666;
      border-radius: 4px;
    }
    
    .control-group h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #00ccff;
    }
  </style>
  <!-- Import map to resolve "three" module specifier -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="info">
    <strong>Robot Simulator</strong><br>
    Use the control panel to adjust the robot camera view rotation.
  </div>
  <div id="controlPanel">
    <label for="cameraRotationInput">Camera View Rotation (¬∞): </label>
    <input type="range" id="cameraRotationInput" min="-180" max="180" value="0" step="1">
    <span id="cameraRotationValue">0</span>
  </div>
  <div id="hud" style="position:absolute; bottom:10px; left:10px; color:#fff; background:rgba(0,0,0,0.6); padding:10px; border-radius:4px; z-index:1;">
  Collisions: <span id="collisionCount">0</span>
</div>

  <!-- Position Info -->
  <div id="positionInfo">
    <strong>Robot Position</strong><br>
    X: <span id="robotX">0.0</span><br>
    Z: <span id="robotZ">0.0</span><br>
    Rotation: <span id="robotRotation">0¬∞</span>
  </div>

  <!-- Navigation Control Panel -->
  <div id="navigationPanel">
    <h3 style="margin: 0 0 10px 0; color: #00ccff;">ü§ñ Robot Controls</h3>
    
    <div class="control-group">
      <h4>Movement Controls</h4>
      <div class="direction-grid">
        <button class="nav-button" onclick="moveRobot(-5, 5)">‚Üñ NW</button>
        <button class="nav-button" onclick="moveRobot(0, 8)">‚Üë Forward</button>
        <button class="nav-button" onclick="moveRobot(5, 5)">‚Üó NE</button>
        <button class="nav-button" onclick="turnRobot(-45)">‚Ü∫ Left</button>
        <button class="nav-button danger" onclick="stopRobot()">‚èπ STOP</button>
        <button class="nav-button" onclick="turnRobot(45)">‚Üª Right</button>
        <button class="nav-button" onclick="moveRobot(-5, -5)">‚Üô SW</button>
        <button class="nav-button" onclick="moveRobot(0, -8)">‚Üì Back</button>
        <button class="nav-button" onclick="moveRobot(5, -5)">‚Üò SE</button>
      </div>
    </div>
    
    <div class="control-group">
      <h4>Quick Actions</h4>
      <button class="nav-button" onclick="captureRobotImage()">üì∏ Capture</button>
      <button class="nav-button danger" onclick="resetRobot()">üîÑ Reset</button>
    </div>
    
    <div class="control-group">
      <h4>Goal Setting</h4>
      <button class="nav-button goal" onclick="setGoal('NE')">üéØ NE Corner</button>
      <button class="nav-button goal" onclick="setGoal('NW')">üéØ NW Corner</button>
      <button class="nav-button goal" onclick="setGoal('SE')">üéØ SE Corner</button>
      <button class="nav-button goal" onclick="setGoal('SW')">üéØ SW Corner</button>
    </div>
    
    <div class="control-group">
      <h4>Autonomous Mode</h4>
      <button class="nav-button" onclick="startAutonomousNavigation()">ü§ñ Auto Navigate</button>
      <button class="nav-button" onclick="toggleObstacles()">üéÆ Toggle Moving Obstacles</button>
    </div>
  </div>

  <!-- Use module script for Three.js and OrbitControls -->
 
  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js';

  // === SETUP: Scene, Camera, Renderer ===
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 20, 30);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10, 20, 10);
  scene.add(dirLight);

  // === FLOOR & ENV ===
  const floorGeo = new THREE.PlaneGeometry(100, 100);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // Obstacles & helpers
  let obstacles = [];
  const obstacleGeometry = new THREE.BoxGeometry(4, 4, 4);
  const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

  function addObstacleAt(x, y=2, z=0) {
    const obs = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
    obs.position.set(x, y, z);
    obs.boundingBox = new THREE.Box3().setFromObject(obs);
    scene.add(obs);
    obstacles.push(obs);
    return obs;
  }

  let collisionCount = 0;
  const collisionCountEl = document.getElementById('collisionCount');
  function updateCollisionHUD() { collisionCountEl.textContent = String(collisionCount); }
  updateCollisionHUD();


  // Initial obstacles
  const obstaclePositions = [
    { x: 10, y: 2, z: 0 }, { x: -10, y: 2, z: -10 }, { x: 0, y: 2, z: 10 },
    { x: 15, y: 2, z: 5 }, { x: -12, y: 2, z: 12 }, { x: 5, y: 2, z: -15 },
    { x: -8, y: 2, z: -5 }, { x: 20, y: 2, z: 20 }, { x: -18, y: 2, z: -3 },
    { x: 13, y: 2, z: -7 }, { x: -7, y: 2, z: 8 }, { x: 18, y: 2, z: -10 },
    { x: -5, y: 2, z: 17 }, { x: 12, y: 2, z: 13 }, { x: -16, y: 2, z: -14 },
    { x: 3, y: 2, z: -12 }, { x: -14, y: 2, z: 0 }, { x: 7, y: 2, z: 16 },
    { x: -20, y: 2, z: 10 }, { x: 0, y: 2, z: -20 }, { x: 4, y: 2, z: 4 }
  ];
  obstaclePositions.forEach(p => addObstacleAt(p.x, p.y, p.z));

  // === ROBOT ===
  const robot = new THREE.Group();

  const bodyGeometry = new THREE.BoxGeometry(2, 3, 1);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.4 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.set(0, 1.5, 0);
  robot.add(body);

  const headGeometry = new THREE.SphereGeometry(0.75, 32, 32);
  const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffcccc, metalness: 0.3, roughness: 0.5 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.set(0, 3.25, 0);
  robot.add(head);

  const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 16);
  const armMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.4 });
  const leftArm = new THREE.Mesh(armGeometry, armMaterial);
  leftArm.rotation.z = Math.PI / 2; leftArm.position.set(-1.3, 2, 0); robot.add(leftArm);
  const rightArm = new THREE.Mesh(armGeometry, armMaterial);
  rightArm.rotation.z = Math.PI / 2; rightArm.position.set(1.3, 2, 0); robot.add(rightArm);

  const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 16);
  const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.2, roughness: 0.7 });
  const leftLeg = new THREE.Mesh(legGeometry, legMaterial); leftLeg.position.set(-0.5, 0.75, 0); robot.add(leftLeg);
  const rightLeg = new THREE.Mesh(legGeometry, legMaterial); rightLeg.position.set(0.5, 0.75, 0); robot.add(rightLeg);

  robot.position.set(0, 0, 0);
  scene.add(robot);
  let robotBox = new THREE.Box3().setFromObject(robot);

  // Robot camera attached to head
  const robotCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  robotCamera.position.set(0, 0.5, 0);
  head.add(robotCamera);

  // === GOAL POST ===
  let goalMesh = null;
  let goalBox = null;
  function setGoalAt(pos) {
    if (!goalMesh) {
      const pole = new THREE.CylinderGeometry(0.2, 0.2, 3, 16);
      const poleMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const flag = new THREE.BoxGeometry(1.5, 0.8, 0.05);
      const flagMat = new THREE.MeshStandardMaterial({ color: 0x00ccff });

      const goalGroup = new THREE.Group();
      const poleMesh = new THREE.Mesh(pole, poleMat);
      poleMesh.position.set(0, 1.5, 0);
      const flagMesh = new THREE.Mesh(flag, flagMat);
      flagMesh.position.set(0.9, 2.2, 0);
      goalGroup.add(poleMesh); goalGroup.add(flagMesh);

      goalMesh = goalGroup;
      scene.add(goalMesh);
      goalBox = new THREE.Box3().setFromObject(goalMesh);
    }
    goalMesh.position.set(pos.x, pos.y ?? 0, pos.z);
    goalBox.setFromObject(goalMesh);
  }

  // === WEBSOCKET ===
  const ws = new WebSocket("ws://localhost:8080");
  ws.onopen = () => {
    console.log("WebSocket connected");
    ws.send(JSON.stringify({ type: "connection", message: "Robot simulator connected." }));
  };
  ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    console.log("Received message:", msg);

    // Absolute Movement
    if (msg.command === "move" && msg.target) {
      targetPos = new THREE.Vector3(msg.target.x, msg.target.y ?? 0, msg.target.z);
      moving = true;
      robot.userData.relative = false;
      ws.send(JSON.stringify({ type: "confirmation", message: "Move command received", target: msg.target }));
    }
    // Relative Movement
    else if (msg.command === "move_relative" && (msg.turn !== undefined) && (msg.distance !== undefined)) {
      const angleRad = msg.turn * (Math.PI / 180);
      robot.rotation.y += angleRad;
      targetPos = robot.position.clone().add(
        new THREE.Vector3(Math.sin(robot.rotation.y), 0, Math.cos(robot.rotation.y))
          .multiplyScalar(msg.distance)
      );
      moving = true;
      robot.userData.relative = true;
      ws.send(JSON.stringify({ type: "confirmation", message: "Relative move command executed", target: { angle: msg.turn, distance: msg.distance } }));
    }
    // Stop
    else if (msg.command === "stop") {
      moving = false; targetPos = null;
      ws.send(JSON.stringify({ type: "confirmation", message: "Stop command executed" }));
    }
    // Capture image
    else if (msg.command === "capture_image") {
      captureImage();
    }
    // NEW: Set Goal
    else if (msg.command === "set_goal" && msg.position) {
      setGoalAt(msg.position);
      ws.send(JSON.stringify({ type: "confirmation", message: "Goal set", position: msg.position }));
    }
    // NEW: Replace obstacles
    else if (msg.command === "set_obstacles" && Array.isArray(msg.positions)) {
      // Remove old
      obstacles.forEach(o => scene.remove(o));
      obstacles = [];
      // Add new
      msg.positions.forEach(p => addObstacleAt(p.x, p.y ?? 2, p.z));
      // Reset velocities array to match new obstacles if moving
      if (movingObstacles.enabled) {
        movingObstacles.velocities = buildVelocitiesArray(msg.positions.length, movingObstacles.velocities);
      }
      ws.send(JSON.stringify({ type: "confirmation", message: "Obstacles updated", count: obstacles.length }));
    }
    // NEW: Obstacle motion control
    else if (msg.command === "set_obstacle_motion") {
      movingObstacles.enabled = !!msg.enabled;
      movingObstacles.speed = typeof msg.speed === 'number' ? msg.speed : movingObstacles.speed;
      movingObstacles.bounds = msg.bounds || movingObstacles.bounds;
      movingObstacles.bounce = (msg.bounce !== undefined) ? !!msg.bounce : movingObstacles.bounce;

      // Align velocities array length with obstacles count
      movingObstacles.velocities = buildVelocitiesArray(
        obstacles.length,
        Array.isArray(msg.velocities) ? msg.velocities : null
      );
      ws.send(JSON.stringify({ type: "confirmation", message: "Obstacle motion updated", enabled: movingObstacles.enabled }));
    }

    else if (msg.command === "reset") {
      // stop motion
      moving = false; targetPos = null;

      // reset robot pose & color
      robot.position.set(0, 0, 0);
      robot.rotation.set(0, 0, 0);
      body.material.color.set(0xff0000);

      // reset local counter
      collisionCount = 0;
      updateCollisionHUD();

      // optional: remove goal highlight color if any
      // (no-op if you want to keep goal)
      ws.send(JSON.stringify({ type: "confirmation", message: "Simulator reset" }));
    }

  };
  ws.onerror = (e) => console.error("WebSocket error:", e);
  ws.onclose = () => console.log("WebSocket connection closed");

  // === MOVEMENT vars ===
  let targetPos = null;
  let moving = false;
  const speed = 0.1;

  // === CAPTURE ===
  function captureImage() {
    renderer.render(scene, robotCamera);
    const imageData = renderer.domElement.toDataURL("image/png");
    ws.send(JSON.stringify({
      type: "capture_image_response",
      image: imageData,
      timestamp: Date.now(),
      position: { x: robot.position.x, y: robot.position.y, z: robot.position.z }
    }));
    renderer.render(scene, camera);
  }

  // === UI: Camera rotation ===
  const cameraRotationInput = document.getElementById('cameraRotationInput');
  const cameraRotationValue = document.getElementById('cameraRotationValue');
  cameraRotationInput.addEventListener('input', () => {
    const angle = parseFloat(cameraRotationInput.value);
    cameraRotationValue.textContent = angle;
    robotCamera.rotation.y = angle * (Math.PI / 180);
  });

  // === OBSTACLE MOTION STATE ===
  const clock = new THREE.Clock();
  const movingObstacles = {
    enabled: false,
    speed: 0.05, // scalar multiplier per frame
    bounds: { minX: -45, maxX: 45, minZ: -45, maxZ: 45 },
    bounce: true,
    velocities: [] // array of {x: number, z: number}
  };

  function buildVelocitiesArray(n, provided) {
    const arr = new Array(n);
    for (let i = 0; i < n; i++) {
      if (provided && typeof provided[i] === 'object') {
        const vx = Number(provided[i].x ?? 0);
        const vz = Number(provided[i].z ?? 0);
        arr[i] = { x: vx, z: vz };
      } else {
        // random gentle motion if not provided
        arr[i] = { x: (Math.random() * 2 - 1), z: (Math.random() * 2 - 1) };
      }
    }
    return arr;
  }
  // Initialize velocities to match initial obstacles
  movingObstacles.velocities = buildVelocitiesArray(obstacles.length, null);

  function moveObstacles(delta) {
    if (!movingObstacles.enabled) return;
    const s = movingObstacles.speed;
    const { minX, maxX, minZ, maxZ } = movingObstacles.bounds;
    obstacles.forEach((obs, i) => {
      const v = movingObstacles.velocities[i] || { x: 0, z: 0 };
      obs.position.x += v.x * s;
      obs.position.z += v.z * s;

      // bounce on bounds
      if (movingObstacles.bounce) {
        if (obs.position.x < minX || obs.position.x > maxX) {
          v.x *= -1;
          // clamp inside
          obs.position.x = Math.max(minX, Math.min(maxX, obs.position.x));
        }
        if (obs.position.z < minZ || obs.position.z > maxZ) {
          v.z *= -1;
          obs.position.z = Math.max(minZ, Math.min(maxZ, obs.position.z));
        }
        movingObstacles.velocities[i] = v;
      } else {
        // wrap
        if (obs.position.x < minX) obs.position.x = maxX;
        if (obs.position.x > maxX) obs.position.x = minX;
        if (obs.position.z < minZ) obs.position.z = maxZ;
        if (obs.position.z > maxZ) obs.position.z = minZ;
      }
      // update bounding box
      obs.boundingBox.setFromObject(obs);
    });
  }

  // === ANIMATION LOOP ===
  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    controls.update();

    // Robot movement
    if (moving && targetPos) {
      const direction = new THREE.Vector3().subVectors(targetPos, robot.position);
      const dist = direction.length();
      if (dist > 0.1) {
        direction.normalize();
        robot.position.addScaledVector(direction, speed);
        if (!robot.userData.relative) robot.lookAt(targetPos);
      } else {
        moving = false; targetPos = null;
        ws.send(JSON.stringify({ type: "confirmation", message: "Arrived at target", position: robot.position }));
        robot.userData.relative = false;
      }
    }

    // Update robot bounding box and check collisions
    robotBox.setFromObject(robot);
    for (const obs of obstacles) {
      if (robotBox.intersectsBox(obs.boundingBox)) {
        moving = false; targetPos = null;
        body.material.color.set(0xffff00);

        // bump counter + update HUD
        collisionCount += 1;
        updateCollisionHUD();

        // notify server (already existed, keep it)
        ws.send(JSON.stringify({
          type: "collision",
          collision: true,
          position: { x: robot.position.x, y: robot.position.y, z: robot.position.z },
          obstacle: { position: obs.position }
        }));
        break;
      }
    }

    // Move obstacles (if enabled)
    moveObstacles(delta);

    // Check goal reach
    if (goalMesh && goalBox) {
      goalBox.setFromObject(goalMesh);
      if (robotBox.intersectsBox(goalBox)) {
        ws.send(JSON.stringify({
          type: "goal_reached",
          position: { x: robot.position.x, y: robot.position.y, z: robot.position.z }
        }));
        // visual feedback
        body.material.color.set(0x00ffff);
      }
    }

    renderer.render(scene, camera);
  }
  animate();

  // === NAVIGATION BUTTON FUNCTIONS ===
  
  // Make functions available globally for button onclick handlers
  window.moveRobot = function(x, z) {
    console.log(`Moving robot to relative position: (${x}, ${z})`);
    targetPos = robot.position.clone().add(new THREE.Vector3(x, 0, z));
    moving = true;
    robot.userData.relative = false;
  };
  
  window.turnRobot = function(angle) {
    console.log(`Turning robot ${angle} degrees`);
    const angleRad = angle * (Math.PI / 180);
    robot.rotation.y += angleRad;
    updatePositionInfo();
  };
  
  window.stopRobot = function() {
    console.log('Stopping robot');
    moving = false;
    targetPos = null;
    body.material.color.set(0xff0000); // Reset color
  };
  
  window.resetRobot = function() {
    console.log('Resetting robot');
    robot.position.set(0, 0, 0);
    robot.rotation.set(0, 0, 0);
    body.material.color.set(0xff0000);
    moving = false;
    targetPos = null;
    collisionCount = 0;
    updateCollisionHUD();
    updatePositionInfo();
    
    // Send reset via WebSocket
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: "reset_request",
        message: "Manual reset from UI"
      }));
    }
  };
  
  window.captureRobotImage = function() {
    console.log('Capturing robot image');
    captureImage();
  };
  
  window.setGoal = function(corner) {
    console.log(`Setting goal to ${corner} corner`);
    const positions = {
      'NE': {x: 45, y: 0, z: -45},
      'NW': {x: -45, y: 0, z: -45},
      'SE': {x: 45, y: 0, z: 45},
      'SW': {x: -45, y: 0, z: 45}
    };
    
    if (positions[corner]) {
      setGoalAt(positions[corner]);
      console.log(`Goal set to ${corner} at position:`, positions[corner]);
    }
  };
  
  let obstaclesMoving = false;
  window.toggleObstacles = function() {
    obstaclesMoving = !obstaclesMoving;
    movingObstacles.enabled = obstaclesMoving;
    console.log(`Moving obstacles: ${obstaclesMoving ? 'ENABLED' : 'DISABLED'}`);
    
    // Update button text
    const button = event.target;
    button.textContent = obstaclesMoving ? 'üéÆ Stop Moving Obstacles' : 'üéÆ Start Moving Obstacles';
  };
  
  window.startAutonomousNavigation = function() {
    console.log('Starting autonomous navigation mode');
    alert('Autonomous Navigation Mode\n\nThe robot will now attempt to navigate autonomously!\n\nSet a goal first using the goal buttons, then watch the robot navigate automatically.');
    
    // You can integrate this with your autonomous system
    // For now, we'll just demonstrate basic autonomous behavior
    if (goalMesh) {
      console.log('Goal detected, starting autonomous navigation...');
      // This would trigger your autonomous navigation algorithm
    } else {
      alert('Please set a goal first using one of the corner buttons!');
    }
  };
  
  // Function to update position info display
  function updatePositionInfo() {
    document.getElementById('robotX').textContent = robot.position.x.toFixed(1);
    document.getElementById('robotZ').textContent = robot.position.z.toFixed(1);
    document.getElementById('robotRotation').textContent = Math.round(robot.rotation.y * 180 / Math.PI) + '¬∞';
  }
  
  // Update position info in animation loop
  const originalAnimate = animate;
  animate = function() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    controls.update();

    // Robot movement
    if (moving && targetPos) {
      const direction = new THREE.Vector3().subVectors(targetPos, robot.position);
      const dist = direction.length();
      if (dist > 0.1) {
        direction.normalize();
        robot.position.addScaledVector(direction, speed);
        if (!robot.userData.relative) robot.lookAt(targetPos);
      } else {
        moving = false; targetPos = null;
        ws.send(JSON.stringify({ type: "confirmation", message: "Arrived at target", position: robot.position }));
        robot.userData.relative = false;
      }
    }

    // Update robot bounding box and check collisions
    robotBox.setFromObject(robot);
    for (const obs of obstacles) {
      if (robotBox.intersectsBox(obs.boundingBox)) {
        moving = false; targetPos = null;
        body.material.color.set(0xffff00);

        // bump counter + update HUD
        collisionCount += 1;
        updateCollisionHUD();

        // notify server (already existed, keep it)
        ws.send(JSON.stringify({
          type: "collision",
          collision: true,
          position: { x: robot.position.x, y: robot.position.y, z: robot.position.z },
          obstacle: { position: obs.position }
        }));
        break;
      }
    }

    // Move obstacles (if enabled)
    moveObstacles(delta);

    // Check goal reach
    if (goalMesh && goalBox) {
      goalBox.setFromObject(goalMesh);
      if (robotBox.intersectsBox(goalBox)) {
        ws.send(JSON.stringify({
          type: "goal_reached",
          position: { x: robot.position.x, y: robot.position.y, z: robot.position.z }
        }));
        // visual feedback
        body.material.color.set(0x00ffff);
      }
    }

    renderer.render(scene, camera);
    updatePositionInfo(); // Update position display every frame
  };
  
  // Keyboard controls
  document.addEventListener('keydown', function(event) {
    switch(event.key) {
      case 'ArrowUp':
      case 'w':
      case 'W':
        moveRobot(0, 5);
        break;
      case 'ArrowDown':
      case 's':
      case 'S':
        moveRobot(0, -5);
        break;
      case 'ArrowLeft':
      case 'a':
      case 'A':
        turnRobot(-45);
        break;
      case 'ArrowRight':
      case 'd':
      case 'D':
        turnRobot(45);
        break;
      case ' ': // Spacebar
        event.preventDefault();
        stopRobot();
        break;
      case 'r':
      case 'R':
        resetRobot();
        break;
      case 'c':
      case 'C':
        captureRobotImage();
        break;
    }
  });
  
  // Initial position update
  updatePositionInfo();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>